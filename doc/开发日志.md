# SuperScrcpy开发日志

## 2021/10/9

**新发现问题：**

- Unix域套接字相关知识（这一步具体问题是在建立反向代理那一步，他使用的域套接字来表示，我没看懂）
- 为什么他一端用的域套接字的名字，一端用的套接字的名字

**已收获知识：**

- adb的使用思路

**总结：**

​	我之所以会对这个项目感到无从下手，是因为我没有完全理解他的思路，现在我理解了：

1. 首先是将scrcpy-sercer推送到手机。这一部分是用于**采集**手机上的视频数据（使用指令adb push）
2. 启动反向代理。这一步是用来建立手机和电脑之间的连接，所谓反向代理，就是把电脑当作服务器，手机作为客户端，然后手机向电脑指定端口发送数据。（使用指令adb reverse）
3. 电脑监听反向代理的端口，用于接收数据
4. 启动scrcpy-server，用于采集数据（使用指令adb shell app_process，这句指令的意思是命令行启动一个程序）
5. 接收scrcpy-server采集的数据，进行通信

在我们的qt程序中，需要启动一个外部应用adb，在qt中启动外部程序由类**QProcess**来实现，所以我们新建一个类Adbprocess继承QProcess，用于启动外部应用adb。

## 2021/10/10

**已收获知识：**

- 每次程序有标准化输出或者标准化错误时，程序就会发出一个信号，我们可以利用这个信号来接收输出的内容

- 添加子模块的步骤：

  - 在.pro所在的文件夹里再新建一个文件夹，文件夹的名称即为子模块的名称

  - 在.pro文件中添加子模块

  - 把.pro文件拷贝进新建的文件夹中，并重命名，后缀名改为.pri

  - 删除.pri文件里面的内容，右键添加新类即可
  
- 在server模块中是如何使用**状态机**实现一步一步完成步骤的

**新发现问题：**

- qt网络编程
- 连接是在什么时候创建的
  - 是不是当建立反向代理之后就是建立连接了？应该是！这一步就相当于connect？

## 2021/10/12

**已收获的知识：**

- 回答上面的问题，**连接是什么时候创建的？**
  - 首先不是建立反向代理之后创建的，这里手机作为客户端，连接是由手机上的scrcpy-server发起的
  - 对的步骤应该是建立反向代理->PC监听对应端口->手机端的scrcpy-server执行实现预定好的指令，启动反向代理，**这时候才相当于建立了一个连接**，这里由Server::execute()函数实现，这个函数执行后
- m_serverProcess是在启动server服务，也就是开始传数据时用的

## 2021/10/15

**已收获的知识：**

- 生产者消费者问题，以及为什么**加锁的顺序有变**
- 为什么需要改进server模块

**新发现的问题：**

- qt多线程之间的区别，**看了之后文章后的几种方法**
- 为什么明明可以多线程，还要用生产者消费者模型（多线程同步）
- 我觉得应该是因为，文章中提到的多线程，**只是使用了一个单独的线程**，并没有体现到同步的作用
- 只有加上**多线程同步**，才实现了同步

## 2021/10/18

**新发现的问题：**

- qt的一些基础用法已经全部忘记了
- 需要重新看一看
- 还有C++的东西

## 2021/11/1

**新发现的问题：**

- readInfo()函数中，read()函数的用法，看文档
- 学习qt的网络编程

## 2021/11/4

**已收获的知识：**

- **把指针作为if的条件判断**，其实就等于“这个指针是否有值”，为Null就代表错误

**总结：**

​	今天理解了这个项目的网络逻辑，明天就是学习**它是如何做到持续不断的传输数据**

​	生产者、消费者

​	多线程同步

​	把**音视频**看完

​	不能只是**看完**，我需要的是**理解**，去感受他的思想

## 2021/11/5

**已收获的知识：**

- 所谓“读”、“写”都是对应存放数据的区域的

**新发现的问题：**

- qt之中生产者消费者问题
- **强制类型转换**
- 重写QTcpServer的疑惑
  - 为什么不重写nextPendingConnection(）函数，改变它的返回值来到达需求
  - 而要重写另外一个虚函数呢？
  - 回答是：重写这一步我没看懂，**但是他最终还是强制类型转换了**

**总结：**

​	我想要优化线程就主要在**解码器模块**研究

## 2021/11/8

**已收获的知识：**

- QByteArray 字节数组，它和普通数组的区别在于它的基本元素是字节，它一般用于存储原始二进制数据，或者嵌入式开发，可以用作数据传输的缓冲区
- QBuffer 为QByteArray提供了一个访问设备（对于服务端来说就是客户端）的接口

## 2022/2/19

**开发计划：**

1. 重新制作一个UI
2. 合并业务逻辑的代码
3. 优化

业务交给后端去处理，前端做展示就好了。

B端，代表企业用户商家，英文是Business，是互联网产品中的商家界面（即：管理平台）。

**B端产品**是服务于某一个行业的企业的产品。同时，意味着行业属性非常强。因为你是服务于企业的，那么他们的业务就是你的产品逻辑，需要你理解他们的业务。

B端产品来说，要解决的主要是不同生产关系的**协作**沟通需求。

互联网市场的*G端*指的是To Government（面向政府客户），各地政府在社会管理和服务工作中也常常需要引入先进的科学技术，提高管理成效，优化服务流程。

**C端产品**是服务于大众群体的产品。在同一个场景中，比你的好用，用户便易弃用你。所以要做好用户体验，了解用户预期。

对于C端产品而言，需要至少有一个核心的主要功能点能满足用户的某一项诉求。围绕这个具体的核心功能，再去考虑附加增值服务。

实际上，我们口口声声的业务逻辑，是只用代码实现的真实业务的规则映射。

**明天计划：**

- 写UI
- 研究qml和C++通信

## 2022/2/20

**已收获的知识：**

- qt编译器的版本，qt的版本必须对齐
- 有关编译器我的想法：
  - 可不可以使用msvc2017再对齐qt的版本
  - **felgo中**，对齐qt版本是在kit，编译器的qt version里
  - 如果直接是qt quick，在新建项目时就可以选择qt版本

## 2022/2/22

**已收获的知识：**

- qt资源机制

  1. 将资源文件夹拷贝到项目目录，最好的拷贝文件夹，方便整理；

  2. 右键项目->添加新文件->qt->qt recourse File->给资源文件起名；

  3. res生成res.qrc；

  4. open in editor 编辑资源；

  5. 添加前缀，添加文件；

  6. 使用：

     ​	“：+前缀名+文件名”

     当有多个资源文件时也不用区分，因为前缀后面的路径才是有效的，也就是文件的路径是固定的，只是开发者用这种方式整合了文件。

     类似于相对路径。

- C++类注册进qml类型系统

  - ```c++
    Q_PROPERTY(QString userName READ userName WRITE setUserName NOTIFY userNameChanged)
    ```

  - property名称，从哪里读，从哪里写，槽

## 2022/2/23

**已收获的知识：**

- ![img](https://pics5.baidu.com/feed/0e2442a7d933c8955131315d2c18a2f68202005f.jpeg?token=8ffa5263abb665c5bac18684d9c1149d)

## 2022/3/1

**已收获的知识：**

- **项目文件夹不能有空格！！！！**
- 否则就会报各种错误，因为他一直在运行之前的程序

## 2022/3/2

- adbprocess中getadbpath很有可能是错误的

- C++和qml的交互方式一共有3种

  - 如果是注册，那么必须要实例化类才能使用

  - 否则可以使用这种“push”的方式：

    - ```C++
      qmlRegisterType<QmlType>("com.type.QmlType", 1, 0, "Type");
      
          QQmlApplicationEngine engine;
          QmlType qmlType;
          engine.rootContext()->setContextProperty("qmlType", &qmlType);
      ```

  - 注册的语句必须写在前面，否则程序加载qml后类型都还没注册到qml类型系统中

##  2022/3/3

- ```C++
  QString("CLASSPATH=%1").arg(DEVICE_SERVER_PATH); // 后面的会把%1替换掉
  ```

## 2022/3/5

app文件夹里面放所有源码
main.cpp直接放在app中
其它模块放在不同文件夹中
以子项目的形式导入
子项目会收录在主文件夹得.pro文件中

库文件放在app的上层目录

## 2022/3/10

- 回调函数的意义：
  - 回调函数能够将函数作为参数传递进来
  - 通过更换回调函数，我们可以实现本函数的不同功能，甚至不需要更改本函数的代码
- 函数指针：
  - int(*func)(int,int);
  - func=&add2;//指针赋值,或者func=add2; add2与&add2意义相同

## 2022/4/20

- 音视频解码流程：
  - **解协议**，音视频在网络上传播时用。
  - **解封装**，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。
  - **解码**的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。
  - **视音频同步**的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来

## 2022/4/22

**问题：**

- 总是提示“程序运行错误”
  - 猜测和注册类到qml文件系统中有关
  - 尝试不注册类，看是否还会出bug
    - 程序依旧有bug
    - 猜测应该是某个模块有问题
    - 猜测，如果cpp中有错误会导致程序无法运行
    - 发现decoder模块有问题

**想法：**

- 电脑支持手机投屏，当电视用

**调试：**

1. 只保留adb模块，重构，修改qml，能够执行，注释掉注册进qml
2. adb+server+common，重构，能够运行
3. 基本确定问题在decoder模块

- 猜测是第三方库连接失败
- **正确！！**
- 原因是没有找到第三方库！！！应该把动态库拷贝到构建目录下

## 2022/5/16

**想法：**

- adb模块负责封装adb程序

- server模块用于启动服务，和手机建立连接，这个过程中将使用到adb模块

- decoder模块会得到server模块和手机建立的**套接字**，从而解码数据

- render模块会得到decoder解码出的数据，从而**渲染**

## 2022/5/24

为了解决对象生命周期的问题，那三个类都应该注册到qml文件系统中。

## 2022/6/6

- 在UI部分点击start，要让后端的server模块启动

  - 在qml中使用C++业务类，基本流程如下：

    1. 将C++注册进入QML引擎，C++类型在qml中当成一个子组件使用

    2. 在qml中完成信号与槽的绑定

    3. 要使用C++的方法需要将该方法标注

       ```C++
       Q_INVOKABLE void sendSignal();
       ```

​	**ps:**需要继承QObject才可以注册!!

## 2022/6/7

​	现在的问题是在qml中无法对对象进行取地址操作，所以我只有退而求其次，通过一个模块把后端暴露出来。

​	注册之后报奇怪的错可能是没有重新qmake的原因
